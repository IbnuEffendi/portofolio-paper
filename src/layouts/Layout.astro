---
import "../styles/global.css";
interface Props { title: string; }
const { title } = Astro.props;
---

<!doctype html>
<html lang="en" class="scroll-smooth">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Lora:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
        <!-- Boxicons -->
        <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
        
        <title>{title}</title>

        <!-- SCRIPT MENCEGAH FLASH (FOUC) -->
        <script is:inline>
            const theme = (() => {
                if (typeof localStorage !== 'undefined' && localStorage.getItem('theme')) {
                    return localStorage.getItem('theme');
                }
                if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    return 'dark';
                }
                return 'light';
            })();
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        </script>
    </head>
    
    <!-- Body transition colors agar perubahan tema halus -->
    <body class="bg-paper text-ink font-sans antialiased relative min-h-screen overflow-x-hidden transition-colors duration-500">
        
        <!-- === THEME TOGGLE BUTTON === -->
        <button id="theme-toggle" class="fixed top-6 right-6 z-50 p-3 rounded-full bg-paper border border-ink/20 text-ink hover:border-accent hover:text-accent transition-all duration-300 shadow-lg group cursor-pointer">
            <!-- Icon Sun (Muncul di Dark Mode) -->
            <i class='bx bx-sun text-xl hidden dark:block animate-spin-slow'></i>
            <!-- Icon Moon (Muncul di Light Mode) -->
            <i class='bx bx-moon text-xl block dark:hidden group-hover:-rotate-12 transition-transform'></i>
        </button>

        <!-- === LAYER 1: DYNAMIC BACKGROUND === -->
        <div class="fixed inset-0 pointer-events-none z-0">
            <!-- Grid Pattern (CSS Handled) -->
            <div class="bg-grid-pattern opacity-100"></div>
            
            <!-- CANVAS: Highlight Grid -->
            <canvas id="grid-highlight-canvas" class="absolute inset-0 z-0"></canvas>
            
            <!-- Noise Texture -->
            <div class="bg-noise"></div>
            
            <!-- Vignette -->
            <div class="bg-vignette"></div>

            <!-- CANVAS: Sirkuit Ular -->
            <canvas id="circuit-canvas" class="absolute inset-0 opacity-[0.4] z-0"></canvas>
        </div>

        <!-- === LAYER 2: TECHNICAL RULER (CSS Handled) === -->
        <div class="fixed inset-0 pointer-events-none z-20 p-4 sm:p-6">
            <div class="relative w-full h-full border border-ink/10 rounded-sm transition-colors duration-500">
                <div class="absolute top-0 left-0 w-full h-[10px] bg-ruler-x opacity-30"></div>
                <div class="absolute bottom-0 left-0 w-full h-[10px] bg-ruler-x opacity-30"></div>
                <div class="absolute top-0 left-0 h-full w-[10px] bg-ruler-y opacity-30"></div>
                <div class="absolute top-0 right-0 h-full w-[10px] bg-ruler-y opacity-30"></div>

                <!-- Corner Markers -->
                <div class="absolute top-0 left-0 w-4 h-4 border-t-2 border-l-2 border-accent transition-colors duration-500"></div>
                <div class="absolute top-0 right-0 w-4 h-4 border-t-2 border-r-2 border-accent transition-colors duration-500"></div>
                <div class="absolute bottom-0 left-0 w-4 h-4 border-b-2 border-l-2 border-accent transition-colors duration-500"></div>
                <div class="absolute bottom-0 right-0 w-4 h-4 border-b-2 border-r-2 border-accent transition-colors duration-500"></div>

                <!-- Coordinates -->
                <div class="absolute top-3 left-4 text-[9px] font-mono text-ink/30 tracking-widest transition-colors duration-500">SYS.RDY // 2026</div>
                <div class="absolute bottom-3 right-4 text-[9px] font-mono text-ink/30 tracking-widest transition-colors duration-500">X:00 Y:00</div>
            </div>
        </div>

        <!-- === LAYER 3: KONTEN UTAMA === -->
        <div class="relative z-30 px-10 sm:px-20 py-16">
            <slot />
        </div>

        <script>
            // --- VARIABEL WARNA DINAMIS ---
            function getThemeColors() {
                const style = getComputedStyle(document.body);
                return {
                    ink: style.getPropertyValue('--color-ink').trim(),
                    paper: style.getPropertyValue('--color-paper').trim(),
                    accent: style.getPropertyValue('--color-accent').trim(),
                    // Helper untuk mengubah hex ke rgba
                    paperRgba: (alpha: number) => {
                        const hex = style.getPropertyValue('--color-paper').trim();
                        // Handle short hex like #fff
                        const fullHex = hex.length === 4 ? '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3] : hex;
                        const r = parseInt(fullHex.slice(1, 3), 16);
                        const g = parseInt(fullHex.slice(3, 5), 16);
                        const b = parseInt(fullHex.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    },
                    accentRgba: (alpha: number) => {
                        const hex = style.getPropertyValue('--color-accent').trim();
                        const fullHex = hex.length === 4 ? '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3] : hex;
                        const r = parseInt(fullHex.slice(1, 3), 16);
                        const g = parseInt(fullHex.slice(3, 5), 16);
                        const b = parseInt(fullHex.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    }
                };
            }

            let colors = getThemeColors();

            // --- THEME TOGGLE LOGIC ---
            const themeToggleBtn = document.getElementById('theme-toggle');
            
            const handleToggleClick = () => {
                const element = document.documentElement;
                element.classList.toggle("dark");

                const isDark = element.classList.contains("dark");
                localStorage.setItem("theme", isDark ? "dark" : "light");
                
                // Update warna canvas setelah transisi CSS selesai (sedikit delay)
                setTimeout(() => {
                    colors = getThemeColors();
                }, 50); 
            };

            if (themeToggleBtn) {
                themeToggleBtn.addEventListener("click", handleToggleClick);
            }


            // === CANVAS 1: GRID HIGHLIGHT ===
            const gCanvas = document.getElementById('grid-highlight-canvas') as HTMLCanvasElement;
            const gCtx = gCanvas.getContext('2d');
            let gWidth: number, gHeight: number;
            let mouse = { x: -1000, y: -1000 };
            let trail = { x: -1000, y: -1000 };
            let ambient = { x: -400, y: -400 };
            let time = 0;
            let randomBreathOffset = 0;
            const gridSize = 40; 

            function resizeGrid() {
                gWidth = window.innerWidth;
                gHeight = window.innerHeight;
                gCanvas.width = gWidth;
                gCanvas.height = gHeight;
            }
            window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
            function lerp(start: number, end: number, factor: number) { return start + (end - start) * factor; }

            function drawGridHighlight() {
                if (!gCtx) return;
                gCtx.clearRect(0, 0, gWidth, gHeight);
                trail.x = lerp(trail.x, mouse.x, 0.12);
                trail.y = lerp(trail.y, mouse.y, 0.12);
                ambient.x += 3.5; ambient.y += 3.5; 
                if (ambient.x > gWidth + 500 || ambient.y > gHeight + 500) { ambient.x = -500; ambient.y = -500 + (Math.random() * 400 - 200); }
                time += 0.05; randomBreathOffset += (Math.random() - 0.5) * 0.1;

                const renderLightSource = (cx: number, cy: number, baseRadius: number, intensityMult: number) => {
                    const breath = Math.sin(time + randomBreathOffset) * (baseRadius * 0.15); 
                    const jitter = Math.sin(time * 3) * 5; 
                    const currentRadius = baseRadius + breath + jitter; 
                    const startCol = Math.floor((cx - currentRadius) / gridSize);
                    const endCol = Math.ceil((cx + currentRadius) / gridSize);
                    const startRow = Math.floor((cy - currentRadius) / gridSize);
                    const endRow = Math.ceil((cy + currentRadius) / gridSize);

                    for (let i = startCol; i <= endCol; i++) {
                        for (let j = startRow; j <= endRow; j++) {
                            const x = i * gridSize;
                            const y = j * gridSize;
                            const dx = cx - x;
                            const dy = cy - y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < currentRadius) {
                                const intensity = Math.pow(1 - dist / currentRadius, 2) * intensityMult;
                                const dotSize = 2 + (intensity * 3.5); 

                                gCtx!.beginPath();
                                // USE DYNAMIC COLOR
                                gCtx!.fillStyle = colors.accentRgba(intensity * 0.5); 
                                gCtx!.arc(x, y, dotSize / 2, 0, Math.PI * 2);
                                gCtx!.fill();
                                
                                gCtx!.beginPath();
                                gCtx!.strokeStyle = colors.accentRgba(intensity * 0.15);
                                gCtx!.lineWidth = 1;
                                gCtx!.moveTo(x - 4, y); gCtx!.lineTo(x + 4, y);
                                gCtx!.moveTo(x, y - 4); gCtx!.lineTo(x, y + 4);
                                gCtx!.stroke();
                            }
                        }
                    }
                };
                renderLightSource(trail.x, trail.y, 300, 1.0);
                renderLightSource(ambient.x, ambient.y, 450, 0.6);
                requestAnimationFrame(drawGridHighlight);
            }
            window.addEventListener('resize', resizeGrid);
            resizeGrid();
            drawGridHighlight();


            // === CANVAS 2: SIRKUIT ULAR ===
            const cCanvas = document.getElementById('circuit-canvas') as HTMLCanvasElement;
            const cCtx = cCanvas.getContext('2d');
            let cWidth: number, cHeight: number;

            function resizeCircuit() { cWidth = window.innerWidth; cHeight = window.innerHeight; cCanvas.width = cWidth; cCanvas.height = cHeight; }

            // DEFINISI CLASS TRACER YANG DIPERBAIKI (Tipe Data Eksplisit)
            class Tracer {
                x!: number; 
                y!: number; 
                dir!: { x: number, y: number }; 
                life!: number; 
                speed: number;

                constructor() { 
                    this.speed = 2; 
                    this.reset(); 
                }
                
                reset() { 
                    this.x = Math.floor(Math.random() * (cWidth/gridSize)) * gridSize; 
                    this.y = Math.floor(Math.random() * (cHeight/gridSize)) * gridSize; 
                    this.life = Math.random() * 150 + 100; 
                    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                    this.dir = dirs[Math.floor(Math.random()*4)];
                }

                update() { 
                    this.x += this.dir.x * this.speed; 
                    this.y += this.dir.y * this.speed; 
                    
                    if (cCtx) { 
                        // USE DYNAMIC COLOR
                        cCtx.fillStyle = colors.accent; 
                        cCtx.fillRect(this.x - 1, this.y - 1, 3, 3); 

                        if (Math.random() < 0.03) {
                            cCtx.beginPath();
                            cCtx.fillStyle = colors.accentRgba(0.3);
                            cCtx.arc(this.x, this.y, 6 + Math.random() * 6, 0, Math.PI * 2);
                            cCtx.fill();
                        }
                    } 
                    if (this.x % gridSize === 0 && this.y % gridSize === 0 && Math.random() < 0.3) {
                        const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                        this.dir = dirs[Math.floor(Math.random()*4)];
                    }
                    this.life--; 
                    if (this.x<0 || this.x>cWidth || this.y<0 || this.y>cHeight || this.life<=0) {
                        if (cCtx) {
                            cCtx.beginPath();
                            cCtx.fillStyle = colors.accentRgba(0.5);
                            cCtx.arc(this.x, this.y, 15, 0, Math.PI * 2); 
                            cCtx.fill();
                        }
                        this.reset(); 
                    }
                }
            }
            
            const tracers: Tracer[] = [];
            for (let i = 0; i < 6; i++) { tracers.push(new Tracer()); }

            function animateCircuit() { 
                if (cCtx) { 
                    // USE DYNAMIC COLOR for trailing effect
                    cCtx.fillStyle = colors.paperRgba(0.05); 
                    cCtx.fillRect(0,0,cWidth,cHeight); 
                } 
                tracers.forEach(t => t.update()); 
                requestAnimationFrame(animateCircuit); 
            }
            window.addEventListener('resize', resizeCircuit);
            resizeCircuit();
            animateCircuit();
        </script>
    </body>
</html>